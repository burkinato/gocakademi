import { pool } from '../database/connection.js';
import { User, UserWithPermissions, PaginationParams, PaginatedResponse, FilterParams } from '../types/index.js';
import { PermissionRepository } from './PermissionRepository.js';

export class UserRepository {
  private permissionRepo: PermissionRepository;

  constructor() {
    this.permissionRepo = new PermissionRepository();
  }

  // ============================================================================
  // BASIC CRUD
  // ============================================================================

  async findByEmail(email: string): Promise<User | null> {
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
  }

  async findById(id: number): Promise<User | null> {
    const result = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
    return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
  }

  async create(userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    const result = await pool.query(
      `INSERT INTO users (
        username, email, password, password_hash, first_name, last_name, role, is_active
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *`,
      [
        (userData as any).username || null,
        userData.email,
        userData.password,
        userData.password,
        userData.firstName,
        userData.lastName,
        userData.role,
        userData.isActive,
      ]
    );
    return this.mapToUser(result.rows[0]);
  }

  async createBasic(params: { email: string; password: string; firstName: string; lastName: string; role: 'student' | 'instructor' | 'admin'; isActive?: boolean }): Promise<User> {
    const result = await pool.query(
      `INSERT INTO users (email, password, first_name, last_name, role, is_active)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [
        params.email,
        params.password,
        async findAll(pagination ?: PaginationParams): Promise < PaginatedResponse < User >> {
          const page = pagination?.page || 1;
          const limit = pagination?.limit || 50;
          const offset = (page - 1) * limit;
          const sortBy = pagination?.sortBy || 'created_at';
          const sortOrder = pagination?.sortOrder || 'desc';

          // Get total count
          const countResult = await pool.query('SELECT COUNT(*) FROM users');
          const total = parseInt(countResult.rows[0].count);

          // Get paginated data
          const result = await pool.query(
            `SELECT * FROM users ORDER BY ${sortBy} ${sortOrder} LIMIT $1 OFFSET $2`,
            [limit, offset]
          );

          return {
            data: result.rows.map(this.mapToUser),
            pagination: {
              page,
              limit,
              total,
              totalPages: Math.ceil(total / limit),
            },
          };
        }

  async findByRole(role: 'student' | 'instructor' | 'admin', pagination ?: PaginationParams): Promise < PaginatedResponse < User >> {
          const page = pagination?.page || 1;
          const limit = pagination?.limit || 50;
          const offset = (page - 1) * limit;

          // Get total count
          const countResult = await pool.query('SELECT COUNT(*) FROM users WHERE role = $1', [role]);
          const total = parseInt(countResult.rows[0].count);

          // Get paginated data
          const result = await pool.query(
            'SELECT * FROM users WHERE role = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3',
            [role, limit, offset]
          );

          return {
            data: result.rows.map(this.mapToUser),
            pagination: {
              page,
              limit,
              total,
              totalPages: Math.ceil(total / limit),
            },
          };
        }

  async searchUsers(filters: FilterParams, pagination ?: PaginationParams): Promise < PaginatedResponse < User >> {
          const page = pagination?.page || 1;
          const limit = pagination?.limit || 50;
          const offset = (page - 1) * limit;

          let whereConditions: string[] = [];
          let queryParams: any[] = [];
          let paramCount = 1;

          if(filters.search) {
            whereConditions.push(
              `(first_name ILIKE $${paramCount} OR last_name ILIKE $${paramCount} OR email ILIKE $${paramCount})`
            );
    queryParams.push(`%${filters.search}%`);
    paramCount++;
  }

  if(filters.role) {
    whereConditions.push(`role = $${paramCount}`);
    queryParams.push(filters.role);
    paramCount++;
  }

  if(filters.isActive !== undefined) {
  whereConditions.push(`is_active = $${paramCount}`);
  queryParams.push(filters.isActive);
  paramCount++;
}

if (filters.startDate) {
  whereConditions.push(`created_at >= $${paramCount}`);
  queryParams.push(filters.startDate);
  paramCount++;
}

if (filters.endDate) {
  whereConditions.push(`created_at <= $${paramCount}`);
  queryParams.push(filters.endDate);
  paramCount++;
}

const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';

// Get total count
const countResult = await pool.query(
  `SELECT COUNT(*) FROM users ${whereClause}`,
  queryParams
);
const total = parseInt(countResult.rows[0].count);

// Get paginated data
const result = await pool.query(
  `SELECT * FROM users ${whereClause} ORDER BY created_at DESC LIMIT $${paramCount} OFFSET $${paramCount + 1}`,
  [...queryParams, limit, offset]
);

return {
  data: result.rows.map(this.mapToUser),
  pagination: {
    page,
    limit,
    total,
    totalPages: Math.ceil(total / limit),
  },
};
  }

  async findWithPermissions(id: number): Promise < UserWithPermissions | null > {
  const user = await this.findById(id);
  if(!user) return null;

  const permissions = await this.permissionRepo.findByUser(id);

  return {
    ...user,
    permissions,
  };
}

  // ============================================================================
  // STATUS & VERIFICATION
  // ============================================================================

  async updateStatus(id: number, isActive: boolean): Promise < User | null > {
  const result = await pool.query(
    'UPDATE users SET is_active = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING *',
    [isActive, id]
  );
  return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
}

  async updateLastLogin(id: number): Promise < void> {
  await pool.query(
    'UPDATE users SET last_login_at = CURRENT_TIMESTAMP WHERE id = $1',
    [id]
  );
}

  async verifyEmail(id: number): Promise < User | null > {
  const result = await pool.query(
    'UPDATE users SET email_verified = true, email_verified_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING *',
    [id]
  );
  return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
}

  async verifyPhone(id: number): Promise < User | null > {
  const result = await pool.query(
    'UPDATE users SET phone_verified = true, phone_verified_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING *',
    [id]
  );
  return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
}

  async enable2FA(id: number, secret: string): Promise < User | null > {
  const result = await pool.query(
    'UPDATE users SET two_factor_enabled = true, two_factor_secret = $1 WHERE id = $2 RETURNING *',
    [secret, id]
  );
  return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
}

  async disable2FA(id: number): Promise < User | null > {
  const result = await pool.query(
    'UPDATE users SET two_factor_enabled = false, two_factor_secret = NULL WHERE id = $1 RETURNING *',
    [id]
  );
  return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
}

  // ============================================================================
  // MAPPER
  // ============================================================================

  private mapToUser(row: any): User {
  return {
    id: row.id,
    username: row.username,
    email: row.email,
    password: row.password,
    firstName: row.first_name,
    lastName: row.last_name,
    role: row.role,
    isActive: row.is_active,
    phone: row.phone,
    address: row.address,
    city: row.city,
    state: row.state,
    country: row.country,
    postalCode: row.postal_code,
    dateOfBirth: row.date_of_birth,
    profileImageUrl: row.profile_image_url,
    bio: row.bio,
    lastLoginAt: row.last_login_at,
    emailVerified: row.email_verified,
    emailVerifiedAt: row.email_verified_at,
    phoneVerified: row.phone_verified,
    phoneVerifiedAt: row.phone_verified_at,
    twoFactorEnabled: row.two_factor_enabled,
    twoFactorSecret: row.two_factor_secret,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}
}